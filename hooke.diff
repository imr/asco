0a1,13
> /*
>  * Copyright (C) 2006 Joao Ramos
>  * Your use of this code is subject to the terms and conditions of the
>  * GNU general public license version 2. See "COPYING" or
>  * http://www.gnu.org/licenses/gpl.html
>  *
>  * Plug-in to add to 'Eldo', 'HSPICE', 'LTSpice' and 'Spectre' circuit simulator optimization capabilities
>  *
>  */
> 
> 
> 
> 
135a149
> #include "stdlib.h"
137a152,161
> 
> /* #include "auxfunc.h" */
> #include "initialize.h"
> 
> 
> 
> 
> /*---------Function declarations----------------------------------------*/
> double extern evaluate(int D, double tmp[], char *argv); /* obj. funct. */
> 
140c164
< #define      EPSMIN		(1E-6)	/* ending value of stepsize  */
---
> #define      EPSMIN		(1E-4)	/* ending value of stepsize  */
147,149c171
< #ifdef Woods
< double f();
< #else
---
> 
154,156c176,178
< f(x, n)
< 	   double	   x[VARS];
< 	   int		   n;
---
> f_2_rosen(D, x)
> 	   int		D;
> 	   double	x[VARS];
158,159c180,181
< 	   double	   a, b, c;
< 	   funevals++;
---
> 	   double	a, b, c;
> 	   //funevals++;
166c188
< #endif
---
> 
171,174c193,197
< best_nearby(delta, point, prevbest, nvars)
< 	   double	   delta[VARS], point[VARS];
< 	   double	   prevbest;
< 	   int		   nvars;
---
> best_nearby(delta, point, prevbest, nvars, filename)
> 	double	delta[VARS], point[VARS];
> 	double	prevbest;
> 	int	nvars;
> 	char	*filename;
176,191c199,218
< 	   double	   z[VARS];
< 	   double	   minf, ftmp;
< 	   int		   i;
< 	   minf = prevbest;
< 	   for (i = 0; i < nvars; i++)
< 		   z[i] = point[i];
< 	   for (i = 0; i < nvars; i++) {
< 		   z[i] = point[i] + delta[i];
< 		   ftmp = f(z, nvars);
< 		   if (ftmp < minf)
< 			   minf = ftmp;
< 		   else {
< 			   delta[i] = 0.0 - delta[i];
< 			   z[i] = point[i] + delta[i];
< 			   ftmp = f(z, nvars);
< 			   if (ftmp < minf)
---
> 	double	   z[VARS];
> 	double	   minf, ftmp;
> 	int		   i;
> 	minf = prevbest;
> 	for (i = 0; i < nvars; i++)
> 		z[i] = point[i];
> 	for (i = 0; i < nvars; i++) {
> 		z[i] = point[i] + delta[i];
> 		funevals++;
> 		//ftmp = f_rosen(nvars, z);
> 		ftmp = evaluate(nvars,z,filename);
> 		if (ftmp < minf)
> 			minf = ftmp;
> 		else {
> 			delta[i] = 0.0 - delta[i];
> 			z[i] = point[i] + delta[i];
> 			funevals++;
> 			//ftmp = f_rosen(nvars, z);
> 			ftmp = evaluate(nvars,z,filename);
> 			if (ftmp < minf)
193,199c220,226
< 			   else
< 				   z[i] = point[i];
< 		   }
< 	   }
< 	   for (i = 0; i < nvars; i++)
< 		   point[i] = z[i];
< 	   return (minf);
---
> 			else
> 				z[i] = point[i];
> 		}
> 	}
> 	for (i = 0; i < nvars; i++)
> 		point[i] = z[i];
> 	return (minf);
204,207c231,235
< hooke(nvars, startpt, endpt, rho, epsilon, itermax)
< 	   double	   startpt[VARS], endpt[VARS];
< 	   int		   nvars, itermax;
< 	   double	   rho, epsilon;
---
> hooke(nvars, startpt, endpt, rho, epsilon, itermax, filename)
> 	double	startpt[VARS], endpt[VARS];
> 	int	nvars, itermax;
> 	double	rho, epsilon;
> 	char	*filename;
209,265c237,294
< 	   double	   delta[VARS];
< 	   double	   newf, fbefore, steplength, tmp;
< 	   double	   xbefore[VARS], newx[VARS];
< 	   int		   i, j, keep;
< 	   int		   iters, iadj;
< 	   for (i = 0; i < nvars; i++) {
< 		   newx[i] = xbefore[i] = startpt[i];
< 		   delta[i] = fabs(startpt[i] * rho);
< 		   if (delta[i] == 0.0)
< 			   delta[i] = rho;
< 	   }
< 	   iadj = 0;
< 	   steplength = rho;
< 	   iters = 0;
< 	   fbefore = f(newx, nvars);
< 	   newf = fbefore;
< 	   while ((iters < itermax) && (steplength > epsilon)) {
< 		   iters++;
< 		   iadj++;
< 		   printf("\nAfter %5d funevals, f(x) =  %.4le at\n", funevals, fbefore);
< 		   for (j = 0; j < nvars; j++)
< 			   printf("   x[%2d] = %.4le\n", j, xbefore[j]);
< 		   /* find best new point, one coord at a time */
< 		   for (i = 0; i < nvars; i++) {
< 			   newx[i] = xbefore[i];
< 		   }
< 		   newf = best_nearby(delta, newx, fbefore, nvars);
< 		   /* if we made some improvements, pursue that direction */
< 		   keep = 1;
< 		   while ((newf < fbefore) && (keep == 1)) {
< 			   iadj = 0;
< 			   for (i = 0; i < nvars; i++) {
< 				   /* firstly, arrange the sign of delta[] */
< 				   if (newx[i] <= xbefore[i])
< 					   delta[i] = 0.0 - fabs(delta[i]);
< 				   else
< 					   delta[i] = fabs(delta[i]);
< 				   /* now, move further in this direction */
< 				   tmp = xbefore[i];
< 				   xbefore[i] = newx[i];
< 				   newx[i] = newx[i] + newx[i] - tmp;
< 			   }
< 			   fbefore = newf;
< 			   newf = best_nearby(delta, newx, fbefore, nvars);
< 			   /* if the further (optimistic) move was bad.... */
< 			   if (newf >= fbefore)
< 				   break;
< 			   /* make sure that the differences between the new */
< 			   /* and the old points are due to actual */
< 			   /* displacements; beware of roundoff errors that */
< 			   /* might cause newf < fbefore */
< 			   keep = 0;
< 			   for (i = 0; i < nvars; i++) {
< 				   keep = 1;
< 				   if (fabs(newx[i] - xbefore[i]) >
< 				       (0.5 * fabs(delta[i])))
< 					   break;
---
> 	double	delta[VARS];
> 	double	newf, fbefore, steplength, tmp;
> 	double	xbefore[VARS], newx[VARS];
> 	int	i, j, keep;
> 	int	iters, iadj;
> 	for (i = 0; i < nvars; i++) {
> 		newx[i] = xbefore[i] = startpt[i];
> 		delta[i] = fabs(startpt[i] * rho);
> 		if (delta[i] == 0.0)
> 			delta[i] = rho;
> 	}
> 	iadj = 0;
> 	steplength = rho;
> 	iters = 0;
> 	funevals++;
> 	//fbefore = f_rosen(nvars, newx);
> 	fbefore = evaluate(nvars,newx,filename);
> 	newf = fbefore;
> 	while ((iters < itermax) && (steplength > epsilon)) {
> 		iters++;
> 		iadj++;
> 		printf("\nAfter %5d funevals, f(x) =  %.4le at\n", funevals, fbefore);
> 		for (j = 0; j < nvars; j++)
> 			printf("   x[%2d] = %.4le\n", j, xbefore[j]);
> 		/* find best new point, one coord at a time */
> 		for (i = 0; i < nvars; i++) {
> 			newx[i] = xbefore[i];
> 		}
> 		newf = best_nearby(delta, newx, fbefore, nvars);
> 		/* if we made some improvements, pursue that direction */
> 		keep = 1;
> 		while ((newf < fbefore) && (keep == 1)) {
> 			iadj = 0;
> 			for (i = 0; i < nvars; i++) {
> 				/* firstly, arrange the sign of delta[] */
> 				if (newx[i] <= xbefore[i])
> 					delta[i] = 0.0 - fabs(delta[i]);
> 				else
> 					delta[i] = fabs(delta[i]);
> 				/* now, move further in this direction */
> 				tmp = xbefore[i];
> 				xbefore[i] = newx[i];
> 				newx[i] = newx[i] + newx[i] - tmp;
> 			}
> 			fbefore = newf;
> 			newf = best_nearby(delta, newx, fbefore, nvars);
> 			/* if the further (optimistic) move was bad.... */
> 			if (newf >= fbefore)
> 				break;
> 			/* make sure that the differences between the new */
> 			/* and the old points are due to actual */
> 			/* displacements; beware of roundoff errors that */
> 			/* might cause newf < fbefore */
> 			keep = 0;
> 			for (i = 0; i < nvars; i++) {
> 				keep = 1;
> 				if (fabs(newx[i] - xbefore[i]) > (0.5 * fabs(delta[i])))
> 					break;
267c296
< 					   keep = 0;
---
> 					keep = 0;
269,303c298,308
< 		   }
< 		   if ((steplength >= epsilon) && (newf >= fbefore)) {
< 			   steplength = steplength * rho;
< 			   for (i = 0; i < nvars; i++) {
< 				   delta[i] *= rho;
< 			   }
< 		   }
< 	   }
< 	   for (i = 0; i < nvars; i++)
< 		   endpt[i] = xbefore[i];
< 	   return (iters);
< }
< 
< #ifndef Woods
< main()
< {
< 	   double	   startpt[VARS], endpt[VARS];
< 	   int		   nvars, itermax;
< 	   double	   rho, epsilon;
< 	   int		   i, jj;
< 
< 	   /* starting guess for rosenbrock test function */
< 	   nvars = 2;
< 	   startpt[0] = -1.2;
< 	   startpt[1] = 1.0;
< 
< 
< 
< 	   itermax = IMAX;
< 	   rho = RHO_BEGIN;
< 	   epsilon = EPSMIN;
< 	   jj = hooke(nvars, startpt, endpt, rho, epsilon, itermax);
< 	   printf("\n\n\nHOOKE USED %d ITERATIONS, AND RETURNED\n", jj);
< 	   for (i = 0; i < nvars; i++)
< 		   printf("x[%3d] = %15.7le \n", i, endpt[i]);
---
> 		}
> 		if ((steplength >= epsilon) && (newf >= fbefore)) {
> 			steplength = steplength * rho;
> 			for (i = 0; i < nvars; i++) {
> 				delta[i] *= rho;
> 			}
> 		}
> 	}
> 	for (i = 0; i < nvars; i++)
> 		endpt[i] = xbefore[i];
> 	return (iters);
305,311d309
< #else
< /* The Hooke & Jeeves algorithm works reasonably well on
<  * Rosenbrock's function, but can fare worse on some
<  * standard test functions, depending on rho.  Here is an
<  * example that works well when rho = 0.5, but fares poorly
<  * with rho = 0.6, and better again with rho = 0.8.
<  */
313,315d310
< #ifndef RHO_WOODS
< #define RHO_WOODS 0.6
< #endif
317d311
< /* Woods -- a la More, Garbow & Hillstrom (TOMS algorithm 566) */
319,336d312
< double
< f(x, n)
< 	double	x[VARS];
< 	int	n;
< {
< 	double	s1, s2, s3, t1, t2, t3, t4, t5;
< 	funevals++;
< 	s1 = x[1] - x[0]*x[0];
< 	s2 = 1 - x[0];
< 	s3 = x[1] - 1;
< 	t1 = x[3] - x[2]*x[2];
< 	t2 = 1 - x[2];
< 	t3 = x[3] - 1;
< 	t4 = s3 + t3;
< 	t5 = s3 - t3;
< 	return 100*(s1*s1) + s2*s2 + 90*(t1*t1) + t2*t2
< 		+ 10*(t4*t4) + t5*t5/10.;
< }
338c314,315
< main()
---
> //void main()
> int HJ(int argc, char *argv[])
345,350c322,331
< 	/* starting guess test problem "Woods" */
< 	nvars = 4;
< 	startpt[0] = -3;
< 	startpt[1] = -1;
< 	startpt[2] = -3;
< 	startpt[3] = -1;
---
> 	/* starting guess for rosenbrock test function */
> 	//nvars = 2;
> 	//startpt[0] = -1.2;
> 	//startpt[1] = 1.0;
> 	nvars=0;
> 	while (parameters[nvars].name[0]  != '\0')
> 		nvars++;                                     /*---number of parameters---------------*/
> 	for (i = 0; i < nvars; i++) {
> 		startpt[i] = scaleto(parameters[i].value, parameters[i].minimum, parameters[i].maximum, -10, +10, parameters[i].format);
> 	}
353c334
< 	rho = RHO_WOODS;
---
> 	rho = RHO_BEGIN;
355c336
< 	jj = hooke(nvars, startpt, endpt, rho, epsilon, itermax);
---
> 	jj = hooke(nvars, startpt, endpt, rho, epsilon, itermax, argv[2]);
359c340,341
< 	printf("True answer: f(1, 1, 1, 1) = 0.\n");
---
> 
> 	return(EXIT_SUCCESS);
361c343,349
< #endif
---
> 
> /* The Hooke & Jeeves algorithm works reasonably well on
>  * Rosenbrock's function, but can fare worse on some
>  * standard test functions, depending on rho.  Here is an
>  * example that works well when rho = 0.5, but fares poorly
>  * with rho = 0.6, and better again with rho = 0.8.
>  */
